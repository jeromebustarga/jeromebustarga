<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Jerome Bustarga - Portfolio</title>
<link rel="icon" type="image/png" href="images/favicon.png">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>

<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  background: #0d0d0d;
  color: #e8e8e8;
  overflow: hidden;
  line-height: 1.6;
}

/* Container for centering with scroll if needed */
#gameContainer {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 2;
  overflow: auto; /* Allow scrolling if content is too large */
  padding: 20px;
}

body.power-on #gameContainer {
  display: flex;
}

#gameContainer.hide-cursor,
#gameContainer.hide-cursor * {
  cursor: none !important;
}

.game-arena {
  position: relative;
  width: 90vw;
  max-width: 1200px;
  min-width: 800px;  /* Prevent arena from getting too small */
  height: 70vh;
  min-height: 500px;  /* Minimum height to maintain playability */
  max-height: 700px;  /* Maximum height for very tall screens */
  background: rgba(20, 20, 20, 0.6);
  border: 2px solid rgba(244, 121, 33, 0.2);
  border-radius: 20px;
  backdrop-filter: blur(20px);
  overflow: hidden;
  box-shadow: 0 0 60px rgba(244, 121, 33, 0.1);
  pointer-events: none;
}

/* Small screen adjustments */
@media (max-width: 850px) {
  .game-arena {
    transform: scale(0.85);
    transform-origin: center;
  }
}

@media (max-width: 700px) {
  .game-arena {
    transform: scale(0.7);
    transform-origin: center;
  }
}

@media (max-width: 600px) {
  .game-arena {
    transform: scale(0.6);
    transform-origin: center;
  }
  
  #gameContainer {
    padding: 10px;
  }
}

/* Lightbulb Power Button */
.lightbulb-container {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 10000;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
}

body.power-on .lightbulb-container {
  top: 40px;
  left: 60px;
  transform: translate(0, 0);
  z-index: 10001;
  flex-direction: row;
  gap: 15px;
}

.logo-wrapper {
  display: none;
  align-items: center;
  gap: 15px;
}

body.power-on .logo-wrapper {
  display: flex;
}

.lightbulb {
  width: 50px;
  height: 50px;
  position: relative;
}

.bulb-image {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.bulb-off {
  display: block;
}

.bulb-on {
  display: none;
  filter: drop-shadow(0 0 40px rgba(244, 121, 33, 0.8)) drop-shadow(0 0 80px rgba(244, 121, 33, 0.5));
}

body.power-on .bulb-off {
  display: none;
}

body.power-on .bulb-on {
  display: block;
}

.logo-name {
  font-size: 20px;
  font-weight: 600;
  color: #e8e8e8;
  letter-spacing: 1px;
  white-space: nowrap;
}

.start-button {
  padding: 14px 40px;
  background: rgba(244, 121, 33, 0.1);
  border: 2px solid rgba(244, 121, 33, 0.4);
  color: #f47921;
  font-size: 16px;
  font-weight: 600;
  letter-spacing: 2px;
  text-transform: uppercase;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.3s ease;
  backdrop-filter: blur(10px);
}

.start-button:hover {
  background: rgba(244, 121, 33, 0.2);
  border-color: rgba(244, 121, 33, 0.6);
  transform: translateY(-2px);
  box-shadow: 0 8px 24px rgba(244, 121, 33, 0.3);
}

body.power-on .start-button {
  display: none;
}

.light-rays {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 140px;
  height: 140px;
  opacity: 0;
  transition: opacity 0.6s ease;
}

body.power-on .light-rays {
  opacity: 1;
  animation: rotate 20s linear infinite;
}

.ray {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 2px;
  height: 80px;
  background: linear-gradient(to bottom, rgba(244, 121, 33, 0.4), transparent);
  transform-origin: 50% 0%;
}

.ray:nth-child(1) { transform: translate(-50%, -100%) rotate(0deg); }
.ray:nth-child(2) { transform: translate(-50%, -100%) rotate(45deg); }
.ray:nth-child(3) { transform: translate(-50%, -100%) rotate(90deg); }
.ray:nth-child(4) { transform: translate(-50%, -100%) rotate(135deg); }
.ray:nth-child(5) { transform: translate(-50%, -100%) rotate(180deg); }
.ray:nth-child(6) { transform: translate(-50%, -100%) rotate(225deg); }
.ray:nth-child(7) { transform: translate(-50%, -100%) rotate(270deg); }
.ray:nth-child(8) { transform: translate(-50%, -100%) rotate(315deg); }

@keyframes rotate {
  from { transform: translate(-50%, -50%) rotate(0deg); }
  to { transform: translate(-50%, -50%) rotate(360deg); }
}

.character {
  position: absolute;
  width: 40px;
  height: 60px;
  transition: none;
  z-index: 100;
}

/* MAIN LEVEL - GRID BASED PLATFORMER */
.main-level {
  width: 100%;
  height: 100%;
  display: none;
}

.main-level.active {
  display: grid;
  grid-template-columns: repeat(30, 1fr);
  grid-template-rows: repeat(20, 1fr);
  gap: 1px;
  background: rgba(244, 121, 33, 0.1);
}

.main-grid-cell {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid rgba(244, 121, 33, 0.15);
}

.main-grid-cell.wall {
  background: linear-gradient(135deg, #f47921, #d96a1a);
  border: 1px solid #c25a15;
  box-shadow: inset 0 0.5px 1px rgba(255, 255, 255, 0.2),
              inset 0 -0.5px 1px rgba(0, 0, 0, 0.3);
  z-index: 1;
}

.main-grid-cell.path {
  background: transparent;
  border: none;
}

/* Main Level Doors in grid */
.door {
  position: absolute;
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  gap: 12px;
  pointer-events: none;
  z-index: 50;
}

.door-icon {
  font-size: 52px;
  color: #f47921;
  transition: all 0.3s ease;
  line-height: 1;
}

/* Scale down door icons on smaller grids */
@media (max-width: 850px) {
  .door-icon, .studio-door-icon {
    font-size: 44px;
  }
  .door-label, .studio-door-label {
    font-size: 10px;
  }
}

.door.can-enter .door-icon {
  text-shadow: 0 0 30px rgba(244, 121, 33, 0.8),
               0 0 60px rgba(244, 121, 33, 0.6),
               0 0 90px rgba(244, 121, 33, 0.4);
  animation: iconPulse 0.8s ease-in-out infinite;
}

@keyframes iconPulse {
  0%, 100% {
    text-shadow: 0 0 30px rgba(244, 121, 33, 0.8),
                 0 0 60px rgba(244, 121, 33, 0.6),
                 0 0 90px rgba(244, 121, 33, 0.4);
  }
  50% {
    text-shadow: 0 0 40px rgba(244, 121, 33, 1),
                 0 0 80px rgba(244, 121, 33, 0.8),
                 0 0 120px rgba(244, 121, 33, 0.6);
  }
}

.door-label {
  font-size: 11px;
  font-weight: 600;
  color: #f47921;
  text-transform: uppercase;
  letter-spacing: 1.2px;
  white-space: nowrap;
  line-height: 1;
  transition: all 0.3s ease;
}

.door.can-enter .door-label {
  text-shadow: 0 0 10px rgba(244, 121, 33, 0.6);
}

/* STUDIO LEVEL - GRID BASED MAZE */
.studio-level {
  display: none;
  width: 100%;
  height: 100%;
}

.studio-level.active {
  display: grid;
  grid-template-columns: repeat(30, 1fr);
  grid-template-rows: repeat(20, 1fr);
  gap: 1px;
  background: rgba(244, 121, 33, 0.1);
}

.grid-cell {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid rgba(244, 121, 33, 0.15);
}

.grid-cell.wall {
  background: linear-gradient(135deg, #f47921, #d96a1a);
  border: 1px solid #c25a15;
  box-shadow: inset 0 0.5px 1px rgba(255, 255, 255, 0.2),
              inset 0 -0.5px 1px rgba(0, 0, 0, 0.3);
  z-index: 1;
}

.grid-cell.path {
  background: transparent;
  border: none;
}

/* Studio Doors in grid */
.studio-door {
  position: absolute;
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  gap: 12px;
  pointer-events: none;
  z-index: 50;
}

.studio-door-icon {
  font-size: 52px;
  color: #f47921;
  transition: all 0.3s ease;
  line-height: 1;
}

.studio-door.can-enter .studio-door-icon {
  text-shadow: 0 0 30px rgba(244, 121, 33, 0.8),
               0 0 60px rgba(244, 121, 33, 0.6),
               0 0 90px rgba(244, 121, 33, 0.4);
  animation: iconPulse 0.8s ease-in-out infinite;
}

.studio-door-label {
  font-size: 11px;
  font-weight: 600;
  color: #f47921;
  text-transform: uppercase;
  letter-spacing: 1.2px;
  white-space: nowrap;
  line-height: 1;
}

.studio-door.can-enter .studio-door-label {
  text-shadow: 0 0 10px rgba(244, 121, 33, 0.6);
}

.game-instructions {
  position: absolute;
  bottom: 30px;
  left: 50%;
  transform: translateX(-50%);
  text-align: center;
  color: rgba(244, 121, 33, 0.7);
  font-size: 14px;
  letter-spacing: 1px;
  animation: fadeOutInstructions 4s ease-in-out forwards;
  z-index: 1000;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
}

@keyframes fadeOutInstructions {
  0% { opacity: 1; }
  75% { opacity: 1; }
  100% { opacity: 0; visibility: hidden; }
}

.key-hint {
  display: inline-block;
  background: rgba(244, 121, 33, 0.15);
  border: 1px solid rgba(244, 121, 33, 0.4);
  padding: 4px 10px;
  border-radius: 4px;
  margin: 0 3px;
  font-family: 'Courier New', monospace;
  font-weight: 600;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

.entrance-prompt {
  position: absolute;
  top: -40px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(244, 121, 33, 0.95);
  color: #0d0d0d;
  padding: 6px 12px;
  border-radius: 6px;
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 1px;
  white-space: nowrap;
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  z-index: 60;
}

.door.can-enter .entrance-prompt,
.studio-door.can-enter .entrance-prompt {
  opacity: 1;
  animation: bounce 0.6s ease-in-out infinite;
}

@keyframes bounce {
  0%, 100% { transform: translate(-50%, 0); }
  50% { transform: translate(-50%, -8px); }
}

footer {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 10002;
  font-size: 12px;
  color: rgba(244, 121, 33, 0.5);
  letter-spacing: 1px;
  display: none;
}

body.power-on footer {
  display: block;
}
</style>
</head>
<body>

<div class="lightbulb-container" id="lightbulbContainer">
  <div class="logo-wrapper">
    <div class="lightbulb" id="lightbulb">
      <img src="logo-off.png" alt="Logo Off" class="bulb-image bulb-off" id="bulbOff">
      <img src="images/logo.png" alt="Logo On" class="bulb-image bulb-on" id="bulbOn">
    </div>
    <div class="logo-name">Jerome Bustarga</div>
  </div>
  <button class="start-button" id="startButton">Start</button>
</div>

<div id="gameContainer">
  <div class="game-arena" id="gameArena">
    <div class="character" id="character">
      <canvas id="characterCanvas" width="40" height="60"></canvas>
    </div>

    <!-- MAIN LEVEL - GRID PLATFORMER -->
    <div class="main-level" id="mainLevel">
      <!-- Grid will be generated by JavaScript -->
    </div>

    <!-- STUDIO LEVEL - GRID MAZE -->
    <div class="studio-level" id="studioLevel">
      <!-- Grid will be generated by JavaScript -->
    </div>
  </div>
</div>

<footer>
  © 2025 Jerome Bustarga. All rights reserved.
</footer>

<script>
const lightbulbContainer = document.getElementById('lightbulbContainer');
const startButton = document.getElementById('startButton');
let isPoweredOn = false;

startButton.addEventListener('click', () => {
  if (!isPoweredOn) {
    isPoweredOn = true;
    document.body.classList.add('power-on');
    
    // Spawn character immediately
    requestAnimationFrame(() => {
      const arenaRect = gameArena.getBoundingClientRect();
      const cellWidth = arenaRect.width / 30;
      const cellHeight = arenaRect.height / 20;
      
      // Ground blocks start at row 17 (rows 17-19 are ground)
      // Spawn at row 10 to give a clear drop distance
      charX = (cellWidth * 15) - 20;
      charY = (cellHeight * 10) - 30;
      
      character.style.left = charX + 'px';
      character.style.top = charY + 'px';
      
      // Character is in air, so not grounded
      isGrounded = false;
      velocityY = 0;
      
      // Activate physics immediately for smooth drop
      physicsActive = true;
    });
  }
});

const gameContainer = document.getElementById('gameContainer');

document.addEventListener('mousemove', (e) => {
  if (!isPoweredOn) return;
  
  const rect = gameContainer.getBoundingClientRect();
  const isInside = (
    e.clientX >= rect.left &&
    e.clientX <= rect.right &&
    e.clientY >= rect.top &&
    e.clientY <= rect.bottom
  );
  
  if (isInside) {
    gameContainer.classList.add('hide-cursor');
  } else {
    gameContainer.classList.remove('hide-cursor');
  }
});

const charCanvas = document.getElementById('characterCanvas');
const charCtx = charCanvas.getContext('2d');

function drawCharacter() {
  charCtx.clearRect(0, 0, 40, 60);
  charCtx.fillStyle = '#f47921';
  charCtx.fillRect(12, 8, 16, 16);
  charCtx.fillStyle = '#0d0d0d';
  charCtx.fillRect(15, 13, 4, 4);
  charCtx.fillRect(21, 13, 4, 4);
  charCtx.fillStyle = '#e8e8e8';
  charCtx.fillRect(10, 24, 20, 20);
  charCtx.fillStyle = '#f47921';
  charCtx.fillRect(10, 30, 20, 4);
  charCtx.fillStyle = '#a0a0a0';
  charCtx.fillRect(12, 44, 6, 12);
  charCtx.fillRect(22, 44, 6, 12);
}

drawCharacter();

const character = document.getElementById('character');
const gameArena = document.getElementById('gameArena');
const mainLevel = document.getElementById('mainLevel');
const studioLevel = document.getElementById('studioLevel');

let charX = 100;
let charY = 100;
let velocityX = 0;
let velocityY = 0;
let isGrounded = false;
let currentLevel = 'main';
let physicsActive = false; // New flag to control physics

const GRAVITY = 0.6;
const JUMP_FORCE = -14;
const MOVE_SPEED = 5;
const MAX_FALL_SPEED = 12;

const keys = {
  ArrowLeft: false,
  ArrowRight: false,
  ArrowUp: false,
  ArrowDown: false,
  Space: false
};

// Main level grid layout (30x20 grid) - Platformer style
const mainLevelGrid = [];

for (let row = 0; row < 20; row++) {
  mainLevelGrid[row] = [];
  for (let col = 0; col < 30; col++) {
    // Border walls
    if (row === 0 || row === 19 || col === 0 || col === 29) {
      mainLevelGrid[row][col] = 1;
    }
    // Ground floor (bottom 2 rows)
    else if (row >= 17) {
      mainLevelGrid[row][col] = 1;
    }
    // Left low platform
    else if (col >= 3 && col <= 9 && row === 14) {
      mainLevelGrid[row][col] = 1;
    }
    // Left high platform
    else if (col >= 5 && col <= 11 && row === 10) {
      mainLevelGrid[row][col] = 1;
    }
    // Right low platform
    else if (col >= 20 && col <= 26 && row === 14) {
      mainLevelGrid[row][col] = 1;
    }
    // Right high platform
    else if (col >= 18 && col <= 24 && row === 10) {
      mainLevelGrid[row][col] = 1;
    }
    // Center top platform
    else if (col >= 13 && col <= 16 && row === 6) {
      mainLevelGrid[row][col] = 1;
    }
    // Center mid platform (for access)
    else if (col >= 12 && col <= 17 && row === 13) {
      mainLevelGrid[row][col] = 1;
    }
    // Open paths
    else {
      mainLevelGrid[row][col] = 0;
    }
  }
}

// Door positions for main level - placed at center of bounding boxes
const mainDoorData = [
  { row: 12, col: 6, id: 'doorRepository', icon: 'fa-door-open', label: 'Repository', type: 'repository' },
  { row: 8, col: 21, id: 'doorStudio', icon: 'fa-door-open', label: 'Studio', type: 'studio' },
  { row: 4, col: 14, id: 'doorHome', icon: 'fa-door-closed', label: 'Home', type: 'home' },
  { row: 12, col: 23, id: 'doorAbout', icon: 'fa-user-circle', label: 'About', type: 'about' }
];

// Studio level grid maze layout (30x20 grid) - maze navigation
const studioMazeGrid = [];

for (let row = 0; row < 20; row++) {
  studioMazeGrid[row] = [];
  for (let col = 0; col < 30; col++) {
    // Border walls
    if (row === 0 || row === 19 || col === 0 || col === 29) {
      studioMazeGrid[row][col] = 1;
    }
    // Vertical dividers
    else if ((col === 7 || col === 15 || col === 22) && (row < 6 || (row > 9 && row < 13) || row > 16)) {
      studioMazeGrid[row][col] = 1;
    }
    // Horizontal dividers
    else if ((row === 7 || row === 14) && (col < 6 || (col > 9 && col < 14) || (col > 17 && col < 21) || col > 24)) {
      studioMazeGrid[row][col] = 1;
    }
    // Open paths
    else {
      studioMazeGrid[row][col] = 0;
    }
  }
}

// Door data for studio level - scattered around maze
const studioDoorData = [
  { row: 4, col: 4, id: 'doorIllustrations', icon: 'fa-palette', label: 'Illustrations', type: 'illustrations' },
  { row: 11, col: 11, id: 'doorBranding', icon: 'fa-tag', label: 'Branding', type: 'branding' },
  { row: 4, col: 19, id: 'door3DArt', icon: 'fa-cube', label: '3D Art', type: '3dart' },
  { row: 4, col: 26, id: 'doorWebdesign', icon: 'fa-code', label: 'Web Design', type: 'webdesign' },
  { row: 4, col: 11, id: 'doorFilm', icon: 'fa-film', label: 'Film', type: 'film' },
  { row: 11, col: 19, id: 'doorBack', icon: 'fa-arrow-left', label: 'Back', type: 'back' }
];

// Build main level grid
function buildMainGrid() {
  mainLevel.innerHTML = '';
  
  for (let row = 0; row < mainLevelGrid.length; row++) {
    for (let col = 0; col < mainLevelGrid[row].length; col++) {
      const cell = document.createElement('div');
      cell.className = 'main-grid-cell';
      cell.dataset.row = row;
      cell.dataset.col = col;
      
      if (mainLevelGrid[row][col] === 1) {
        cell.classList.add('wall');
      } else {
        cell.classList.add('path');
      }
      
      // Check if this is a door position
      const doorInfo = mainDoorData.find(d => d.row === row && d.col === col);
      if (doorInfo) {
        const door = document.createElement('div');
        door.className = 'door';
        door.id = doorInfo.id;
        door.dataset.type = doorInfo.type;
        
        const prompt = document.createElement('div');
        prompt.className = 'entrance-prompt';
        prompt.textContent = 'Press SPACE';
        
        const icon = document.createElement('div');
        icon.className = 'door-icon';
        icon.innerHTML = `<i class="fa-solid ${doorInfo.icon}"></i>`;
        
        const label = document.createElement('div');
        label.className = 'door-label';
        label.textContent = doorInfo.label;
        
        door.appendChild(prompt);
        door.appendChild(icon);
        door.appendChild(label);
        cell.appendChild(door);
      }
      
      mainLevel.appendChild(cell);
    }
  }
  
  // Add instructions
  const instructions = document.createElement('div');
  instructions.className = 'game-instructions';
  instructions.innerHTML = `
    Use <span class="key-hint">←</span> <span class="key-hint">→</span> to move • <span class="key-hint">↑</span> to jump • <span class="key-hint">SPACE</span> to enter doors
  `;
  mainLevel.appendChild(instructions);
}

// Build studio level grid
function buildStudioGrid() {
  studioLevel.innerHTML = '';
  
  for (let row = 0; row < studioMazeGrid.length; row++) {
    for (let col = 0; col < studioMazeGrid[row].length; col++) {
      const cell = document.createElement('div');
      cell.className = 'grid-cell';
      cell.dataset.row = row;
      cell.dataset.col = col;
      
      if (studioMazeGrid[row][col] === 1) {
        cell.classList.add('wall');
      } else {
        cell.classList.add('path');
      }
      
      const doorInfo = studioDoorData.find(d => d.row === row && d.col === col);
      if (doorInfo) {
        const door = document.createElement('div');
        door.className = 'studio-door';
        door.id = doorInfo.id;
        door.dataset.type = doorInfo.type;
        
        const prompt = document.createElement('div');
        prompt.className = 'entrance-prompt';
        prompt.textContent = 'Press SPACE';
        
        const icon = document.createElement('div');
        icon.className = 'studio-door-icon';
        icon.innerHTML = `<i class="fa-solid ${doorInfo.icon}"></i>`;
        
        const label = document.createElement('div');
        label.className = 'studio-door-label';
        label.textContent = doorInfo.label;
        
        door.appendChild(prompt);
        door.appendChild(icon);
        door.appendChild(label);
        cell.appendChild(door);
      }
      
      studioLevel.appendChild(cell);
    }
  }
  
  const instructions = document.createElement('div');
  instructions.className = 'game-instructions';
  instructions.innerHTML = `
    Use <span class="key-hint">←</span> <span class="key-hint">↑</span> <span class="key-hint">↓</span> <span class="key-hint">→</span> to move • <span class="key-hint">SPACE</span> to enter doors
  `;
  studioLevel.appendChild(instructions);
}

buildMainGrid();
buildStudioGrid();

// Show main level grid immediately but keep it hidden until powered on
mainLevel.classList.add('active');

function switchToStudioLevel() {
  currentLevel = 'studio';
  mainLevel.classList.remove('active');
  studioLevel.classList.add('active');
  
  velocityX = 0;
  velocityY = 0;
  isGrounded = false;
  physicsActive = false;
  
  setTimeout(() => {
    const arenaRect = gameArena.getBoundingClientRect();
    const cellWidth = arenaRect.width / 30;
    const cellHeight = arenaRect.height / 20;
    
    // Spawn LEFT of back icon (back is at row 11, col 19 - spawn at row 11, col 17)
    charX = (cellWidth * 17) + (cellWidth / 2) - 20;
    charY = (cellHeight * 11) + (cellHeight / 2) - 30;
    
    character.style.left = charX + 'px';
    character.style.top = charY + 'px';
    
    physicsActive = true;
  }, 100);
}

function switchToMainLevel() {
  currentLevel = 'main';
  studioLevel.classList.remove('active');
  mainLevel.classList.add('active');
  
  velocityX = 0;
  velocityY = 0;
  isGrounded = false;
  physicsActive = false;
  
  requestAnimationFrame(() => {
    const arenaRect = gameArena.getBoundingClientRect();
    const cellWidth = arenaRect.width / 30;
    const cellHeight = arenaRect.height / 20;
    
    // Spawn at row 10 (above ground) so character drops
    charX = (cellWidth * 15) - 20;
    charY = (cellHeight * 10) - 30;
    
    character.style.left = charX + 'px';
    character.style.top = charY + 'px';
    
    // Activate physics immediately for smooth drop
    physicsActive = true;
  });
}

window.addEventListener('keydown', (e) => {
  if (e.code in keys || e.code === 'Space') {
    e.preventDefault();
    if (e.code === 'Space') {
      keys.Space = true;
      // Space is ONLY for entering doors
      checkDoorEntry();
    } else if (e.code === 'ArrowUp') {
      keys.ArrowUp = true;
      // ArrowUp is for jumping in main level
      if (currentLevel === 'main' && isGrounded) {
        velocityY = JUMP_FORCE;
        isGrounded = false;
      }
    } else {
      keys[e.code] = true;
    }
  }
});

window.addEventListener('keyup', (e) => {
  if (e.code in keys || e.code === 'Space') {
    if (e.code === 'Space') {
      keys.Space = false;
    } else {
      keys[e.code] = false;
    }
  }
});

function getWalls() {
  if (currentLevel === 'main') {
    return Array.from(document.querySelectorAll('.main-grid-cell.wall'));
  } else {
    return Array.from(document.querySelectorAll('.grid-cell.wall'));
  }
}

// Helper function to get arena scale
function getArenaScale() {
  const computedStyle = window.getComputedStyle(gameArena);
  const transform = computedStyle.transform;
  
  if (transform && transform !== 'none') {
    const values = transform.split('(')[1].split(')')[0].split(',');
    return parseFloat(values[0]);
  }
  return 1;
}

// FIXED: Scale-aware platform collision detection
function checkPlatformCollision(x, y, width, height) {
  const walls = getWalls();
  const arenaRect = gameArena.getBoundingClientRect();
  const scale = getArenaScale();
  
  // Adjust collision box for scale
  const scaledWidth = width * scale;
  const scaledHeight = height * scale;
  
  const charBox = {
    left: arenaRect.left + (x * scale),
    right: arenaRect.left + (x * scale) + scaledWidth,
    top: arenaRect.top + (y * scale),
    bottom: arenaRect.top + (y * scale) + scaledHeight
  };
  
  for (let wall of walls) {
    const wallRect = wall.getBoundingClientRect();
    
    // Dynamic tolerance based on scale
    const tolerance = Math.max(15 * scale, 10);
    
    // Check if character is above platform and falling
    if (charBox.bottom >= wallRect.top - (2 * scale) &&
        charBox.bottom <= wallRect.top + tolerance &&
        charBox.right > wallRect.left + (5 * scale) &&
        charBox.left < wallRect.right - (5 * scale) &&
        velocityY >= 0) {
      return {
        collision: true,
        platformTop: (wallRect.top - arenaRect.top) / scale
      };
    }
  }
  
  return { collision: false };
}

// FIXED: Scale-aware wall collision detection
function isWallAt(x, y) {
  const arenaRect = gameArena.getBoundingClientRect();
  const scale = getArenaScale();
  
  // Dynamic margin based on scale - smaller margin at smaller scales
  const margin = Math.max(6 * scale, 4);
  
  const charBox = {
    left: arenaRect.left + (x * scale) + margin,
    right: arenaRect.left + ((x + 40) * scale) - margin,
    top: arenaRect.top + (y * scale) + margin,
    bottom: arenaRect.top + ((y + 60) * scale) - margin
  };
  
  const walls = getWalls();
  
  for (let wall of walls) {
    const wallRect = wall.getBoundingClientRect();
    
    const overlapping = !(
      charBox.right < wallRect.left ||
      charBox.left > wallRect.right ||
      charBox.bottom < wallRect.top ||
      charBox.top > wallRect.bottom
    );
    
    if (overlapping) {
      return true;
    }
  }
  
  return false;
}

// FIXED: Improved movement function with scale awareness
function moveCharacter() {
  if (!isPoweredOn || !physicsActive) {
    requestAnimationFrame(moveCharacter);
    return;
  }
  
  const arenaRect = gameArena.getBoundingClientRect();
  const scale = getArenaScale();
  
  // Get unscaled arena dimensions
  const unscaledWidth = arenaRect.width / scale;
  const unscaledHeight = arenaRect.height / scale;
  
  if (currentLevel === 'main') {
    // MAIN LEVEL: Left-Right movement + Jumping with gravity
    if (keys.ArrowLeft) {
      velocityX = -MOVE_SPEED;
    } else if (keys.ArrowRight) {
      velocityX = MOVE_SPEED;
    } else {
      velocityX = 0;
    }
    
    // Apply gravity
    if (!isGrounded) {
      velocityY += GRAVITY;
      if (velocityY > MAX_FALL_SPEED) {
        velocityY = MAX_FALL_SPEED;
      }
    }
    
    // Update position
    let newX = charX + velocityX;
    let newY = charY + velocityY;
    
    // Horizontal boundaries (use unscaled dimensions)
    if (newX < 5) newX = 5;
    if (newX > unscaledWidth - 45) newX = unscaledWidth - 45;
    
    // Check horizontal wall collision
    if (!isWallAt(newX, charY)) {
      charX = newX;
    } else {
      velocityX = 0;
    }
    
    // Check platform collision for vertical movement
    const collision = checkPlatformCollision(charX, newY, 40, 60);
    
    if (collision.collision) {
      // Snap to platform top with small offset to prevent embedding
      charY = collision.platformTop - 58;
      velocityY = 0;
      isGrounded = true;
    } else {
      // Check if moving into wall vertically
      if (!isWallAt(charX, newY)) {
        charY = newY;
        isGrounded = false;
      } else {
        // If hitting a wall from side while falling, stop vertical velocity
        if (velocityY > 0) {
          velocityY = 0;
          isGrounded = true;
        }
      }
    }
    
    // Bottom boundary safety - ensure character doesn't go below ground
    if (charY > unscaledHeight - 65) {
      charY = unscaledHeight - 65;
      velocityY = 0;
      isGrounded = true;
    }
    
    // Additional ground check for stability
    if (isGrounded) {
      // Check if still on ground
      const stillOnGround = checkPlatformCollision(charX, charY + 2, 40, 60);
      if (!stillOnGround.collision && charY < unscaledHeight - 65) {
        isGrounded = false;
      }
    }
    
  } else {
    // STUDIO LEVEL: Left-Right AND Up-Down movement
    let newX = charX;
    let newY = charY;
    const speed = 4;
    
    if (keys.ArrowLeft && charX > 5) {
      newX = charX - speed;
    }
    if (keys.ArrowRight && charX < unscaledWidth - 45) {
      newX = charX + speed;
    }
    if (keys.ArrowUp && charY > 5) {
      newY = charY - speed;
    }
    if (keys.ArrowDown && charY < unscaledHeight - 65) {
      newY = charY + speed;
    }
    
    // Check horizontal collision
    if (!isWallAt(newX, charY)) {
      charX = newX;
    }
    
    // Check vertical collision
    if (!isWallAt(charX, newY)) {
      charY = newY;
    }
  }
  
  character.style.left = charX + 'px';
  character.style.top = charY + 'px';
  
  checkDoorCollision();
  requestAnimationFrame(moveCharacter);
}

function checkDoorCollision() {
  const charRect = character.getBoundingClientRect();
  
  if (currentLevel === 'main') {
    const doors = document.querySelectorAll('.door');
    doors.forEach(door => {
      updateDoorState(door, isColliding(charRect, door.getBoundingClientRect()));
    });
  } else {
    const studioDoors = document.querySelectorAll('.studio-door');
    studioDoors.forEach(door => {
      updateDoorState(door, isColliding(charRect, door.getBoundingClientRect()));
    });
  }
}

function updateDoorState(door, colliding) {
  if (colliding) {
    door.classList.add('can-enter');
  } else {
    door.classList.remove('can-enter');
  }
}

function isColliding(rect1, rect2) {
  return !(rect1.right < rect2.left || 
           rect1.left > rect2.right || 
           rect1.bottom < rect2.top || 
           rect1.top > rect2.bottom);
}

function checkDoorEntry() {
  let activeDoor;
  
  if (currentLevel === 'main') {
    activeDoor = document.querySelector('.door.can-enter');
  } else {
    activeDoor = document.querySelector('.studio-door.can-enter');
  }
  
  if (activeDoor) {
    const doorType = activeDoor.dataset.type;
    
    if (doorType === 'studio') {
      switchToStudioLevel();
    } else if (doorType === 'back') {
      switchToMainLevel();
    } else {
      enterDoor(doorType);
    }
  }
}

function enterDoor(doorType) {
  console.log(`Entering ${doorType}...`);
  
  switch(doorType) {
    case 'repository':
      window.location.href = 'repository.html';
      break;
    case 'home':
      window.location.href = 'index2.html';
      break;
    case 'about':
      window.location.href = 'about.html';
      break;
    case 'illustrations':
      window.location.href = 'illustrations.html';
      break;
    case 'branding':
      window.location.href = 'logobranding.html';
      break;
    case 'webdesign':
      window.location.href = 'webdesign.html';
      break;
    case 'film':
      window.location.href = 'film.html';
      break;
    case '3dart':
      window.location.href = '3d-art.html';
      break;
  }
}

// Handle window resize
let resizeTimer;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(() => {
    // Recalculate position if needed when window resizes
    if (isPoweredOn && physicsActive) {
      const arenaRect = gameArena.getBoundingClientRect();
      const scale = getArenaScale();
      const unscaledWidth = arenaRect.width / scale;
      const unscaledHeight = arenaRect.height / scale;
      
      // Keep character within bounds
      if (charX > unscaledWidth - 45) {
        charX = unscaledWidth - 45;
      }
      if (charY > unscaledHeight - 65) {
        charY = unscaledHeight - 65;
        isGrounded = true;
      }
      
      character.style.left = charX + 'px';
      character.style.top = charY + 'px';
    }
  }, 100);
});

moveCharacter();

// Mouse trail effect
new p5((p) => {
  let trails = [];
  
  p.setup = () => {
    const canvas = p.createCanvas(p.windowWidth, p.windowHeight);
    canvas.position(0, 0);
    canvas.style('pointer-events', 'none');
    canvas.style('z-index', '1');
    canvas.style('position', 'fixed');
    canvas.style('top', '0');
    canvas.style('left', '0');
    p.clear();
    p.noStroke();
  };

  p.draw = () => {
    p.clear();
    
    for (let i = trails.length - 1; i >= 0; i--) {
      const point = trails[i];
      
      p.fill(255, 255, 255, point.alpha * 0.08);
      p.ellipse(point.x, point.y, point.size * 2);
      
      p.fill(255, 255, 255, point.alpha * 0.3);
      p.ellipse(point.x, point.y, point.size);
      
      point.alpha -= 3;
      point.size *= 0.96;
      if (point.alpha <= 0) trails.splice(i, 1);
    }

    const d = p.dist(p.mouseX, p.mouseY, p.pmouseX, p.pmouseY);
    if (d > 0) {
      const steps = p.max(1, d * 0.5);
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const x = p.lerp(p.pmouseX, p.mouseX, t);
        const y = p.lerp(p.pmouseY, p.mouseY, t);
        trails.push({
          x,
          y,
          size: p.random(6, 10),
          alpha: p.random(120, 150)
        });
      }
    }

    if (trails.length > 600) trails.splice(0, trails.length - 600);
  };

  p.windowResized = () => {
    p.resizeCanvas(p.windowWidth, p.windowHeight);
  };
});
</script>
</body>
</html>